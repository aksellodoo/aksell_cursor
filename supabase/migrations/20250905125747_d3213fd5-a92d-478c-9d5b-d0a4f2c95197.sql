
BEGIN;

-- 1) Tabela de grupos econômicos de compras
CREATE TABLE IF NOT EXISTS public.purchases_economic_groups (
  id_grupo        integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  id              uuid    NOT NULL DEFAULT gen_random_uuid(),
  code            text    UNIQUE,
  name            text,
  ai_suggested_name text,
  name_source     text,
  created_at      timestamptz NOT NULL DEFAULT now(),
  updated_at      timestamptz NOT NULL DEFAULT now(),
  created_by      uuid    NOT NULL
);

-- Função: preencher created_by se vier nulo
CREATE OR REPLACE FUNCTION public.set_created_by_default()
RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN
  IF NEW.created_by IS NULL THEN
    NEW.created_by := auth.uid();
  END IF;
  RETURN NEW;
END;
$$;

-- Função: gerar código "GEC-000001"
CREATE OR REPLACE FUNCTION public.set_purchases_group_code()
RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN
  IF NEW.code IS NULL THEN
    NEW.code := 'GEC-' || lpad(NEW.id_grupo::text, 6, '0');
  END IF;
  RETURN NEW;
END;
$$;

-- Trigger: set created_by
DROP TRIGGER IF EXISTS tg_purchases_groups_set_created_by ON public.purchases_economic_groups;
CREATE TRIGGER tg_purchases_groups_set_created_by
BEFORE INSERT ON public.purchases_economic_groups
FOR EACH ROW
EXECUTE FUNCTION public.set_created_by_default();

-- Trigger: set code
DROP TRIGGER IF EXISTS tg_purchases_groups_set_code ON public.purchases_economic_groups;
CREATE TRIGGER tg_purchases_groups_set_code
BEFORE INSERT ON public.purchases_economic_groups
FOR EACH ROW
EXECUTE FUNCTION public.set_purchases_group_code();

-- Trigger: updated_at
DROP TRIGGER IF EXISTS tg_purchases_groups_updated_at ON public.purchases_economic_groups;
CREATE TRIGGER tg_purchases_groups_updated_at
BEFORE UPDATE ON public.purchases_economic_groups
FOR EACH ROW
EXECUTE FUNCTION public.set_current_timestamp_updated_at();

-- RLS
ALTER TABLE public.purchases_economic_groups ENABLE ROW LEVEL SECURITY;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies 
    WHERE schemaname = 'public' 
      AND tablename = 'purchases_economic_groups'
      AND policyname = 'Purchases groups viewable by authenticated'
  ) THEN
    CREATE POLICY "Purchases groups viewable by authenticated"
      ON public.purchases_economic_groups
      FOR SELECT
      USING (true);
  END IF;
END$$;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies 
    WHERE schemaname = 'public' 
      AND tablename = 'purchases_economic_groups'
      AND policyname = 'Purchases groups insert by creator or admins'
  ) THEN
    CREATE POLICY "Purchases groups insert by creator or admins"
      ON public.purchases_economic_groups
      FOR INSERT
      WITH CHECK (
        (created_by = auth.uid())
        OR EXISTS(
          SELECT 1 FROM public.profiles p 
          WHERE p.id = auth.uid() AND p.role IN ('admin','director')
        )
      );
  END IF;
END$$;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies 
    WHERE schemaname = 'public' 
      AND tablename = 'purchases_economic_groups'
      AND policyname = 'Purchases groups update by owner or admins'
  ) THEN
    CREATE POLICY "Purchases groups update by owner or admins"
      ON public.purchases_economic_groups
      FOR UPDATE
      USING (
        (created_by = auth.uid())
        OR EXISTS(
          SELECT 1 FROM public.profiles p 
          WHERE p.id = auth.uid() AND p.role IN ('admin','director')
        )
      )
      WITH CHECK (
        (created_by = auth.uid())
        OR EXISTS(
          SELECT 1 FROM public.profiles p 
          WHERE p.id = auth.uid() AND p.role IN ('admin','director')
        )
      );
  END IF;
END$$;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies 
    WHERE schemaname = 'public' 
      AND tablename = 'purchases_economic_groups'
      AND policyname = 'Purchases groups delete by owner or admins'
  ) THEN
    CREATE POLICY "Purchases groups delete by owner or admins"
      ON public.purchases_economic_groups
      FOR DELETE
      USING (
        (created_by = auth.uid())
        OR EXISTS(
          SELECT 1 FROM public.profiles p 
          WHERE p.id = auth.uid() AND p.role IN ('admin','director')
        )
      );
  END IF;
END$$;

-- 2) Tabela de membros (apenas fornecedores unificados)
CREATE TABLE IF NOT EXISTS public.purchases_economic_group_members (
  id                  uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  group_id            integer NOT NULL REFERENCES public.purchases_economic_groups(id_grupo) ON DELETE CASCADE,
  unified_supplier_id uuid    NOT NULL REFERENCES public.purchases_unified_suppliers(id) ON DELETE CASCADE,
  created_at          timestamptz NOT NULL DEFAULT now(),
  created_by          uuid    NOT NULL
);

-- Garante 1 grupo por fornecedor unificado (e também evita duplicidade no mesmo grupo)
CREATE UNIQUE INDEX IF NOT EXISTS purchases_group_member_unique_supplier
  ON public.purchases_economic_group_members (unified_supplier_id);
CREATE UNIQUE INDEX IF NOT EXISTS purchases_group_member_unique_pair
  ON public.purchases_economic_group_members (group_id, unified_supplier_id);

-- Trigger: set created_by
DROP TRIGGER IF EXISTS tg_purchases_group_members_set_created_by ON public.purchases_economic_group_members;
CREATE TRIGGER tg_purchases_group_members_set_created_by
BEFORE INSERT ON public.purchases_economic_group_members
FOR EACH ROW
EXECUTE FUNCTION public.set_created_by_default();

-- RLS
ALTER TABLE public.purchases_economic_group_members ENABLE ROW LEVEL SECURITY;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies 
    WHERE schemaname = 'public' 
      AND tablename = 'purchases_economic_group_members'
      AND policyname = 'Purchases group members viewable by authenticated'
  ) THEN
    CREATE POLICY "Purchases group members viewable by authenticated"
      ON public.purchases_economic_group_members
      FOR SELECT
      USING (true);
  END IF;
END$$;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies 
    WHERE schemaname = 'public' 
      AND tablename = 'purchases_economic_group_members'
      AND policyname = 'Purchases group members insert by creator or admins'
  ) THEN
    CREATE POLICY "Purchases group members insert by creator or admins"
      ON public.purchases_economic_group_members
      FOR INSERT
      WITH CHECK (
        (created_by = auth.uid())
        OR EXISTS(
          SELECT 1 FROM public.profiles p 
          WHERE p.id = auth.uid() AND p.role IN ('admin','director')
        )
      );
  END IF;
END$$;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies 
    WHERE schemaname = 'public' 
      AND tablename = 'purchases_economic_group_members'
      AND policyname = 'Purchases group members update by owner or admins'
  ) THEN
    CREATE POLICY "Purchases group members update by owner or admins"
      ON public.purchases_economic_group_members
      FOR UPDATE
      USING (
        (created_by = auth.uid())
        OR EXISTS(
          SELECT 1 FROM public.profiles p 
          WHERE p.id = auth.uid() AND p.role IN ('admin','director')
        )
      )
      WITH CHECK (
        (created_by = auth.uid())
        OR EXISTS(
          SELECT 1 FROM public.profiles p 
          WHERE p.id = auth.uid() AND p.role IN ('admin','director')
        )
      );
  END IF;
END$$;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies 
    WHERE schemaname = 'public' 
      AND tablename = 'purchases_economic_group_members'
      AND policyname = 'Purchases group members delete by owner or admins'
  ) THEN
    CREATE POLICY "Purchases group members delete by owner or admins"
      ON public.purchases_economic_group_members
      FOR DELETE
      USING (
        (created_by = auth.uid())
        OR EXISTS(
          SELECT 1 FROM public.profiles p 
          WHERE p.id = auth.uid() AND p.role IN ('admin','director')
        )
      );
  END IF;
END$$;

-- 3) RPC: listar grupos com contagem de membros
CREATE OR REPLACE FUNCTION public.get_purchases_economic_groups()
RETURNS TABLE(
  id_grupo integer,
  code text,
  name text,
  member_count integer
)
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
SET search_path TO 'public'
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    g.id_grupo,
    g.code,
    COALESCE(g.name, g.ai_suggested_name, 'Grupo ' || lpad(g.id_grupo::text, 6, '0')) AS name,
    COALESCE((
      SELECT COUNT(*) FROM public.purchases_economic_group_members m
      WHERE m.group_id = g.id_grupo
    ), 0)::int AS member_count
  FROM public.purchases_economic_groups g
  ORDER BY g.id_grupo;
END;
$$;

-- 4) RPC: criar novo grupo
CREATE OR REPLACE FUNCTION public.create_purchases_economic_group(p_name text DEFAULT NULL)
RETURNS TABLE(id_grupo integer, code text, name text)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO 'public'
AS $$
DECLARE
  v_id integer;
  v_code text;
  v_name text;
BEGIN
  INSERT INTO public.purchases_economic_groups (name, name_source, created_by)
  VALUES (
    NULLIF(btrim(p_name), ''),
    CASE WHEN p_name IS NOT NULL AND btrim(p_name) <> '' THEN 'manual' ELSE NULL END,
    auth.uid()
  )
  RETURNING id_grupo, code, COALESCE(name, 'Grupo ' || lpad(id_grupo::text, 6, '0'))
  INTO v_id, v_code, v_name;

  RETURN QUERY SELECT v_id, v_code, v_name;
END;
$$;

-- 5) RPC: adicionar fornecedor unificado ao grupo (move se já estiver em outro)
CREATE OR REPLACE FUNCTION public.add_unified_supplier_to_purchases_group(p_id_grupo integer, p_unified_id uuid)
RETURNS json
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO 'public'
AS $$
DECLARE
  v_old_group_id integer;
  v_remaining integer;
BEGIN
  SELECT group_id INTO v_old_group_id
  FROM public.purchases_economic_group_members
  WHERE unified_supplier_id = p_unified_id
  LIMIT 1;

  INSERT INTO public.purchases_economic_group_members (group_id, unified_supplier_id, created_by)
  VALUES (p_id_grupo, p_unified_id, auth.uid())
  ON CONFLICT (unified_supplier_id)
  DO UPDATE SET group_id = EXCLUDED.group_id, created_by = auth.uid(), created_at = now();

  IF v_old_group_id IS NOT NULL AND v_old_group_id <> p_id_grupo THEN
    SELECT COUNT(*) INTO v_remaining FROM public.purchases_economic_group_members WHERE group_id = v_old_group_id;
    IF v_remaining = 0 THEN
      DELETE FROM public.purchases_economic_groups WHERE id_grupo = v_old_group_id;
      RETURN json_build_object('success', true, 'old_group_deleted', true, 'old_group_id', v_old_group_id);
    END IF;
  END IF;

  RETURN json_build_object('success', true, 'old_group_deleted', false, 'old_group_id', v_old_group_id);
END;
$$;

-- 6) RPC: remover fornecedor unificado do grupo (apaga grupo se ficar vazio)
CREATE OR REPLACE FUNCTION public.remove_unified_supplier_from_purchases_group(p_id_grupo integer, p_unified_id uuid)
RETURNS json
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO 'public'
AS $$
DECLARE
  v_remaining integer;
BEGIN
  DELETE FROM public.purchases_economic_group_members
  WHERE group_id = p_id_grupo AND unified_supplier_id = p_unified_id;

  SELECT COUNT(*) INTO v_remaining
  FROM public.purchases_economic_group_members
  WHERE group_id = p_id_grupo;

  IF v_remaining = 0 THEN
    DELETE FROM public.purchases_economic_groups
    WHERE id_grupo = p_id_grupo;

    RETURN json_build_object('success', true, 'group_deleted', true);
  END IF;

  RETURN json_build_object('success', true, 'group_deleted', false);
END;
$$;

-- 7) RPC: listar membros de um grupo (para uso futuro na gestão de membros)
CREATE OR REPLACE FUNCTION public.get_purchases_group_members(p_id_grupo integer)
RETURNS TABLE(
  unified_id uuid,
  display_name text,
  unified_status text,
  protheus_filial text,
  protheus_cod text,
  protheus_loja text
)
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
SET search_path TO 'public'
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    us.id AS unified_id,
    COALESCE(us.short_name, us.commercial_name, us.legal_name, 'Fornecedor ' || LEFT(us.id::text, 8)) AS display_name,
    us.status::text AS unified_status,
    us.protheus_filial::text,
    us.protheus_cod::text,
    us.protheus_loja::text
  FROM public.purchases_economic_group_members m
  JOIN public.purchases_unified_suppliers us
    ON us.id = m.unified_supplier_id
  WHERE m.group_id = p_id_grupo
  ORDER BY display_name;
END;
$$;

COMMIT;
